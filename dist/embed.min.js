!(function (e, t) {
  "object" == typeof exports && "object" == typeof module
    ? (module.exports = t())
    : "function" == typeof define && define.amd
      ? define([], t)
      : "object" == typeof exports
        ? (exports.QualifiedEmbed = t())
        : (e.QualifiedEmbed = t());
})(self, () =>
  (() => {
    "use strict";
    var e = {
        d: (t, n) => {
          for (var o in n)
            e.o(n, o) &&
              !e.o(t, o) &&
              Object.defineProperty(t, o, { enumerable: !0, get: n[o] });
        },
        o: (e, t) => Object.prototype.hasOwnProperty.call(e, t),
        r: (e) => {
          "undefined" != typeof Symbol &&
            Symbol.toStringTag &&
            Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }),
            Object.defineProperty(e, "__esModule", { value: !0 });
        },
      },
      t = {};
    function n() {}
    function o(e) {
      return e;
    }
    function i(...e) {
      const t = /^\/+|\/+$/g;
      return e
        .map((e) => {
          return ((n = e), null == n ? "" : String(n)).replace(t, "");
          var n;
        })
        .filter(o)
        .join("/");
    }
    e.r(t),
      e.d(t, {
        QualifiedEmbedManager: () => O,
        QualifiedEmbeddedAssessment: () => j,
        QualifiedEmbeddedChallenge: () => C,
      });
    const s = { "http:": "80", "https:": "443" },
      r = /^(https?:)?\/\/([^/:]+)?(:(\d+))?/,
      a = ["file:", "data:"];
    var d, c, l, h, u, p, m;
    ((m = d || (d = {})).Call = "call"),
      (m.Reply = "reply"),
      (m.Syn = "syn"),
      (m.SynAck = "synAck"),
      (m.Ack = "ack"),
      (function (e) {
        (e.Fulfilled = "fulfilled"), (e.Rejected = "rejected");
      })(c || (c = {})),
      ((p = l || (l = {})).ConnectionDestroyed = "ConnectionDestroyed"),
      (p.ConnectionTimeout = "ConnectionTimeout"),
      (p.NotInIframe = "NotInIframe"),
      (p.NoIframeSrc = "NoIframeSrc"),
      (function (e) {
        e.DataCloneError = "DataCloneError";
      })(h || (h = {})),
      ((u || (u = {})).Message = "message");
    const f = ({ name: e, message: t, stack: n }) => ({
      name: e,
      message: t,
      stack: n,
    });
    let g = 0;
    const y = () => ++g,
      w = (e, t, n, o, i) => {
        const {
          localName: s,
          local: r,
          remote: a,
          originForSending: h,
          originForReceiving: p,
        } = t;
        let m = !1;
        i(`${s}: Connecting call sender`);
        return (
          n.reduce(
            (e, t) => (
              (e[t] = (
                (e) =>
                (...t) => {
                  let n;
                  i(`${s}: Sending ${e}() call`);
                  try {
                    a.closed && (n = !0);
                  } catch (e) {
                    n = !0;
                  }
                  if ((n && o(), m)) {
                    const t = new Error(
                      `Unable to send ${e}() call due to destroyed connection`,
                    );
                    throw ((t.code = l.ConnectionDestroyed), t);
                  }
                  return new Promise((n, o) => {
                    const l = y(),
                      m = (t) => {
                        if (
                          t.source !== a ||
                          t.data.penpal !== d.Reply ||
                          t.data.id !== l
                        )
                          return;
                        if (t.origin !== p)
                          return void i(
                            `${s} received message from origin ${t.origin} which did not match expected origin ${p}`,
                          );
                        const h = t.data;
                        i(`${s}: Received ${e}() reply`),
                          r.removeEventListener(u.Message, m);
                        let f = h.returnValue;
                        h.returnValueIsError &&
                          (f = ((e) => {
                            const t = new Error();
                            return (
                              Object.keys(e).forEach((n) => (t[n] = e[n])), t
                            );
                          })(f)),
                          (h.resolution === c.Fulfilled ? n : o)(f);
                      };
                    r.addEventListener(u.Message, m);
                    const f = { penpal: d.Call, id: l, methodName: e, args: t };
                    a.postMessage(f, h);
                  });
                }
              )(t)),
              e
            ),
            e,
          ),
          () => {
            m = !0;
          }
        );
      },
      $ = (e) => {
        let {
          iframe: t,
          methods: n = {},
          childOrigin: o,
          timeout: i,
          debug: p = !1,
        } = e;
        const m = (
            (e) =>
            (...t) => {
              e && console.log("[Penpal]", ...t);
            }
          )(p),
          g = (() => {
            const e = [];
            let t = !1;
            return {
              destroy(n) {
                (t = !0),
                  e.forEach((e) => {
                    e(n);
                  });
              },
              onDestroy(n) {
                t ? n() : e.push(n);
              },
            };
          })(),
          { onDestroy: y, destroy: $ } = g;
        o ||
          (((e) => {
            if (!e.src && !e.srcdoc) {
              const e = new Error(
                "Iframe must have src or srcdoc property defined.",
              );
              throw ((e.code = l.NoIframeSrc), e);
            }
          })(t),
          (o = ((e) => {
            if (e && a.find((t) => e.startsWith(t))) return "null";
            const t = document.location,
              n = r.exec(e);
            let o, i, d;
            return (
              n
                ? ((o = n[1] ? n[1] : t.protocol), (i = n[2]), (d = n[4]))
                : ((o = t.protocol), (i = t.hostname), (d = t.port)),
              `${o}//${i}${d && d !== s[o] ? `:${d}` : ""}`
            );
          })(t.src)));
        const E = "null" === o ? "*" : o,
          v = ((e, t, n, o) => (i) => {
            if (i.origin !== n)
              return void e(
                `Parent: Handshake - Received SYN message from origin ${i.origin} which did not match expected origin ${n}`,
              );
            e("Parent: Handshake - Received SYN, responding with SYN-ACK");
            const s = { penpal: d.SynAck, methodNames: Object.keys(t) };
            i.source.postMessage(s, o);
          })(m, n, o, E),
          b = ((e, t, n, o, i) => {
            const { destroy: s, onDestroy: r } = o;
            let a, l;
            const p = {};
            return (o) => {
              if (o.origin !== t)
                return void i(
                  `Parent: Handshake - Received ACK message from origin ${o.origin} which did not match expected origin ${t}`,
                );
              i("Parent: Handshake - Received ACK");
              const m = {
                localName: "Parent",
                local: window,
                remote: o.source,
                originForSending: n,
                originForReceiving: t,
              };
              a && a(),
                (a = ((e, t, n) => {
                  const {
                    localName: o,
                    local: i,
                    remote: s,
                    originForSending: r,
                    originForReceiving: a,
                  } = e;
                  let l = !1;
                  const p = (e) => {
                    if (e.source !== s || e.data.penpal !== d.Call) return;
                    if (e.origin !== a)
                      return void n(
                        `${o} received message from origin ${e.origin} which did not match expected origin ${a}`,
                      );
                    const i = e.data,
                      { methodName: u, args: p, id: m } = i;
                    n(`${o}: Received ${u}() call`);
                    const g = (e) => (t) => {
                      if ((n(`${o}: Sending ${u}() reply`), l))
                        return void n(
                          `${o}: Unable to send ${u}() reply due to destroyed connection`,
                        );
                      const i = {
                        penpal: d.Reply,
                        id: m,
                        resolution: e,
                        returnValue: t,
                      };
                      e === c.Rejected &&
                        t instanceof Error &&
                        ((i.returnValue = f(t)), (i.returnValueIsError = !0));
                      try {
                        s.postMessage(i, r);
                      } catch (e) {
                        if (e.name === h.DataCloneError) {
                          const t = {
                            penpal: d.Reply,
                            id: m,
                            resolution: c.Rejected,
                            returnValue: f(e),
                            returnValueIsError: !0,
                          };
                          s.postMessage(t, r);
                        }
                        throw e;
                      }
                    };
                    new Promise((e) => e(t[u].apply(t, p))).then(
                      g(c.Fulfilled),
                      g(c.Rejected),
                    );
                  };
                  return (
                    i.addEventListener(u.Message, p),
                    () => {
                      (l = !0), i.removeEventListener(u.Message, p);
                    }
                  );
                })(m, e, i)),
                r(a),
                l &&
                  l.forEach((e) => {
                    delete p[e];
                  }),
                (l = o.data.methodNames);
              const g = w(p, m, l, s, i);
              return r(g), p;
            };
          })(n, o, E, g, m),
          I = new Promise((e, n) => {
            const o = ((e, t) => {
                let n;
                return (
                  void 0 !== e &&
                    (n = window.setTimeout(() => {
                      const n = new Error(`Connection timed out after ${e}ms`);
                      (n.code = l.ConnectionTimeout), t(n);
                    }, e)),
                  () => {
                    clearTimeout(n);
                  }
                );
              })(i, $),
              s = (n) => {
                if (n.source === t.contentWindow && n.data)
                  if (n.data.penpal !== d.Syn)
                    if (n.data.penpal !== d.Ack);
                    else {
                      const t = b(n);
                      t && (o(), e(t));
                    }
                  else v(n);
              };
            window.addEventListener(u.Message, s),
              m("Parent: Awaiting handshake"),
              ((e, t) => {
                const { destroy: n, onDestroy: o } = t,
                  i = setInterval(() => {
                    document.contains(e) || (clearInterval(i), n());
                  }, 6e4);
                o(() => {
                  clearInterval(i);
                });
              })(t, g),
              y((e) => {
                window.removeEventListener(u.Message, s),
                  e ||
                    ((e = new Error("Connection destroyed")).code =
                      l.ConnectionDestroyed),
                  n(e);
              });
          });
        return {
          promise: I,
          destroy() {
            $();
          },
        };
      };
    function E(e) {
      let t = e;
      if ("function" == typeof e) t = void 0;
      else if (Array.isArray(e)) t = e.map(E);
      else if ("object" == typeof e) {
        t = {};
        let n = Object.keys(e);
        n.length || (n = Object.getOwnPropertyNames(e)),
          n.forEach((n) => {
            t[n] = E(e[n]);
          });
      }
      return t;
    }
    class v {
      constructor({ node: e }) {
        if (!e)
          throw new Error("Cannot create an embedded editor without a node");
        this.node = e;
        try {
          e.QualifiedEmbed = this;
        } catch (e) {}
        "IFRAME" === e.nodeName
          ? (this.iframe = e)
          : ((this.iframe = document.createElement("iframe")),
            e.appendChild(this.iframe)),
          this.iframe.classList.add("qualified-embedded");
      }
      destroy() {
        if (!this.$$destroyed) {
          if (
            ((this.$$destroyed = !0),
            this.manager &&
              (function (e, t) {
                const n = e.indexOf(t);
                n >= 0 && e.splice(n, 1);
              })(this.manager.editors, this),
            this.iframe &&
              ((this.iframe.src = ""),
              this.iframe !== this.node &&
                this.iframe.parentNode &&
                this.iframe.parentNode.removeChild(this.iframe)),
            this.node)
          )
            try {
              this.node.QualifiedEmbed = null;
            } catch (e) {}
          if (this.connection)
            try {
              this.connection.destroy();
            } catch (e) {}
          this.iframe =
            this.node =
            this.manager =
            this.options =
            this.connection =
            this.childMethods =
              null;
        }
      }
      _initPenpal(e, t = []) {
        const n = this.manager,
          o = {};
        e.forEach((e) => {
          o[e] = (o) => {
            const i =
              "on" +
              ((s = e),
              0 === (s = String(s)).length
                ? s
                : s[0].toUpperCase() + s.slice(1));
            var s;
            const r = { [this._type || "editor"]: this, data: o };
            t.forEach((e) => {
              r[e] = this[e];
            }),
              [this, this.options, n].forEach((e) => {
                e && "function" == typeof e[i] && e[i](r);
              });
          };
        }),
          (this.connection = $({
            iframe: this.iframe,
            timeout: 3e5,
            methods: o,
          })),
          this.connection.promise
            .then((e) => {
              this.childMethods = e;
            })
            .catch((e) => {
              this.$$destroyed ||
                o.loaded({
                  error: e ? e.toString() : "Unknown Connection Error",
                  started: !1,
                });
            });
      }
      _post(e, t) {
        return this.$$destroyed
          ? Promise.reject(Error("Editor has been destroyed"))
          : this.childMethods && this.childMethods[e]
            ? this.childMethods[e](E(t))
            : Promise.reject(Error(`Unable to call method "${e}" on iframe`));
      }
    }
    const b = "https://www.qualified.io";
    function I(e, t) {
      let n;
      try {
        const t = window.localStorage[e];
        n = JSON.parse(t || "{}");
      } catch (e) {}
      return t ? (n || {})[t] : n || {};
    }
    class C extends v {
      constructor({ node: e, challengeId: t, options: n = {}, manager: o }) {
        if ((super({ manager: o, node: e }), o)) {
          if (o.$$destroyed)
            throw new Error(
              "Cannot create an embed on a destroyed manager object",
            );
          (this.manager = o), o.editors.push(this);
        }
        if ((t || (t = e.dataset.qualifiedEmbed), !t))
          throw new Error(
            "Unable to determine challenge ID from node: no value for data-qualified-embed",
          );
        (this.challengeId = t),
          (this.options = Object.assign(
            {},
            o && o.options,
            (o && o.challengeOptions[t]) || {},
            n,
          )),
          this._updateIframe(),
          (this.challengeData = {}),
          this._initPenpal(
            ["ready", "loaded", "change", "runStart", "run"],
            ["challengeId", "manager"],
          );
      }
      update({
        challengeId: e = this.challengeId,
        options: t = null,
        reload: n = !1,
      } = {}) {
        this.$$destroyed ||
          (t && Object.assign(this.options, t),
          n || (e && this.challengeId !== e)
            ? ((this.challengeId = e), this._updateIframe())
            : this._sendOptions());
      }
      start() {
        return this._post("start");
      }
      runTests() {
        return this._post("runTests");
      }
      attempt() {
        return this._post("attempt");
      }
      reset() {
        return this._post("reset");
      }
      reload() {
        this._updateIframe();
      }
      setFileContents(e, t) {
        return this._post("setFileContents", { files: e, cursor: t });
      }
      setRunResult(e) {
        return this._post("setRunResult", e);
      }
      onReady() {
        if (this.options.localStorageId) {
          const e = I(this.options.localStorageId, this.challengeId);
          e &&
            e.files &&
            ((this.options.initialFiles = Object.assign(
              {},
              this.options.initialFiles,
              e.files,
            )),
            e.cursor && (this.options.initialCursor = e.cursor));
        }
        this._sendOptions();
      }
      onLoaded({ data: e }) {
        this.challengeData = e;
      }
      onChange({ data: e }) {
        this.options.localStorageId &&
          (function (e, t, n) {
            const o = I(e);
            o[t] = n;
            try {
              window.localStorage[e] = JSON.stringify(o);
            } catch (e) {}
          })(this.options.localStorageId, this.challengeId, e);
      }
      _sendOptions() {
        this._post("setOptions", this.options);
      }
      _updateIframe() {
        if (this.$$destroyed) return;
        const e = {
            hasAuthToken: !!this.options.authToken,
            theme: this.options.theme,
          },
          t = this.options.baseURL || b;
        this.iframe.src =
          i(t, "embed", this.challengeId) +
          "?" +
          (function (e) {
            return Object.keys(e)
              .filter((t) => e[t])
              .map((t) => `${t}=${encodeURIComponent(e[t])}`)
              .join("&");
          })(e);
      }
    }
    const S = window.document;
    function _(e) {
      if (e.$$destroyed)
        throw new Error(
          "This manager has been destroyed, please create a new one",
        );
    }
    class O {
      static init(e) {
        return new O(e);
      }
      constructor({
        onLoaded: e = n,
        onRun: t = n,
        onRunStart: o = n,
        onChange: i = n,
        autoCreate: s = !1,
        options: r = {},
        challengeOptions: a = {},
      } = {}) {
        var d;
        (this.onLoaded = e),
          (this.onRun = t),
          (this.onRunStart = o),
          (this.onChange = i),
          (this.editors = []),
          (this.options = r),
          (this.challengeOptions = a),
          s &&
            ((d = () => {
              const e = "string" == typeof s ? s : "[data-qualified-embed]";
              Array.from(document.querySelectorAll(e)).forEach((e) => {
                this.createEditor({ node: e });
              });
            }),
            "complete" === S.readyState || "interactive" === S.readyState
              ? window.setTimeout(d, 1)
              : S.addEventListener("DOMContentLoaded", d));
      }
      findEditor({ node: e, challengeId: t } = {}) {
        return (
          _(this),
          (e && this.editors.find((t) => t.node === e)) ||
            (t && this.editors.find((e) => e.challengeId === t)) ||
            !1
        );
      }
      createEditor({ node: e, challengeId: t = null, options: n = {} } = {}) {
        return (
          _(this),
          this.updateEditor({ node: e, challengeId: t, options: n }) ||
            new C({ manager: this, node: e, challengeId: t, options: n })
        );
      }
      updateEditor({ node: e, challengeId: t = null, options: n = {} } = {}) {
        _(this);
        const o = this.findEditor({ node: e, challengeId: t });
        return o && o.update({ challengeId: t, options: n }), o || !1;
      }
      destroy() {
        this.$$destroyed ||
          ((this.$$destroyed = !0),
          this.editors.forEach((e) => {
            e.destroy();
          }),
          (this.editors = null));
      }
    }
    const R = { "/": "_", "+": "-", "=": "~" };
    Object.entries(R).reduce((e, [t, n]) => ((e[n] = t), e), {});
    class j extends v {
      constructor({ node: e, options: t }) {
        if ((super({ node: e }), !t || !t.invitePath || !t.authToken))
          throw new Error(
            "Unable to load an assessment without invitePath and authToken",
          );
        (this._type = "assessment"),
          (this.options = Object.assign({}, t)),
          this._updateIframe(),
          (this.assessmentData = {}),
          this._initPenpal([
            "ready",
            "error",
            "loaded",
            "updated",
            "solutionUpdated",
            "submitted",
          ]);
      }
      next() {
        return this._post("next");
      }
      previous() {
        return this._post("previous");
      }
      welcome() {
        return this.switchChallenge("welcome");
      }
      review() {
        return this.switchChallenge("review");
      }
      submit() {
        return this._post("submit");
      }
      switchChallenge(e) {
        return this._post("switchChallenge", e);
      }
      update({ options: e = null, reload: t = !1 } = {}) {
        if (this.$$destroyed) return;
        let n = !1;
        e &&
          ((n = e.invitePath && e.invitePath !== this.options.invitePath),
          Object.assign(this.options, e)),
          t || n ? this._updateIframe() : this._sendOptions();
      }
      reload() {
        this._updateIframe();
      }
      onReady() {
        this._sendOptions();
      }
      onLoaded({ data: e }) {
        this.assessmentData = e;
      }
      _sendOptions() {
        this._post("setOptions", this.options);
      }
      _updateIframe() {
        if (this.$$destroyed) return;
        const e = this.options.baseURL || b,
          t = this.options.invitePath.replace(
            /^(\/assess\/)([a-fA-F0-9]{24})/,
            (e, t, n) =>
              `${t}${"QE" + btoa(n.replace(/.{2}/g, (e) => String.fromCharCode(parseInt(e, 16)))).replace(/[/=+]/g, (e) => R[e])}`,
          );
        this.iframe.src = i(e, t);
      }
    }
    return t;
  })(),
);
